#!/usr/bin/env python3
# =============================================================================
# DEMUCS-SEPARATE CLI - Audio Separation Tool
# =============================================================================
# Simple CLI for Demucs audio separation:
#   - Input: URL (public/signed) or local audio file
#   - Output: Separated audio (vocals + instrumental)
#
# Usage:
#   demucs-separate --input "https://url/audio.mp3" --output ./results
#   demucs-separate --input "/path/to/audio.wav" --output ./results
#   demucs-separate --help
# =============================================================================

import argparse
import os
import sys
import subprocess
import tempfile
import shutil
from pathlib import Path
from urllib.parse import urlparse

__VERSION__ = '1.0.0'

# =============================================================================
# CONFIGURATION
# =============================================================================
MVSEP_DIR = '/workspace/mvsep'
INFERENCE_SCRIPT = f'{MVSEP_DIR}/inference_demucs.py'

# Demucs parameters
MODEL_OVERHEAD = 4
SAMPLES_PER_GB = 60000
SAFETY_MARGIN = 0.9
MIN_CHUNK_SIZE = 50000
MAX_CHUNK_SIZE = 5000000
CHUNK_REDUCTION = 50000
MAX_ATTEMPTS = 20

OVERLAP_LARGE = 0.0001
OVERLAP_SMALL = 1


# =============================================================================
# LOGGING
# =============================================================================
def log(msg):
    print(f"[demucs-separate] {msg}")


def log_error(msg):
    print(f"[demucs-separate] ERROR: {msg}", file=sys.stderr)


# =============================================================================
# GPU DETECTION
# =============================================================================
def detect_gpu():
    log("Detecting GPU configuration...")

    try:
        result = subprocess.run(
            ['nvidia-smi', '--query-gpu=name', '--format=csv,noheader'],
            capture_output=True, text=True, timeout=10
        )
        gpu_name = result.stdout.strip().split('\n')[0] if result.returncode == 0 else None

        result = subprocess.run(
            ['nvidia-smi', '--query-gpu=memory.total', '--format=csv,noheader,nounits'],
            capture_output=True, text=True, timeout=10
        )
        vram_mb = int(result.stdout.strip().split('\n')[0]) if result.returncode == 0 else 0
        vram_gb = vram_mb // 1024

        if gpu_name and vram_gb > 0:
            log(f"  GPU: {gpu_name}")
            log(f"  VRAM: {vram_gb} GB")

            vram_available = max(1, vram_gb - MODEL_OVERHEAD)
            chunk_size = int(vram_available * SAMPLES_PER_GB * SAFETY_MARGIN)
            chunk_size = max(MIN_CHUNK_SIZE, min(MAX_CHUNK_SIZE, chunk_size))
            log(f"  Chunk size: {chunk_size} samples")

            return chunk_size

    except Exception as e:
        log(f"  GPU detection failed: {e}")

    log("  Using CPU mode with minimum chunk size")
    return MIN_CHUNK_SIZE


# =============================================================================
# INPUT HANDLING
# =============================================================================
def is_url(path):
    """Check if the input is a URL."""
    parsed = urlparse(path)
    return parsed.scheme in ('http', 'https')


def download_audio(url, output_path):
    """Download audio file from URL."""
    log(f"Downloading audio from: {url}")

    cmd = ['wget', '-q', '--show-progress', '-O', str(output_path), url]

    try:
        result = subprocess.run(cmd, timeout=300)
        if result.returncode != 0:
            log_error("Download failed")
            return False

        if not output_path.exists() or output_path.stat().st_size == 0:
            log_error("Downloaded file is empty or missing")
            return False

        log(f"  Downloaded: {output_path.stat().st_size / 1024 / 1024:.1f} MB")
        return True

    except subprocess.TimeoutExpired:
        log_error("Download timeout (5 min)")
        return False
    except Exception as e:
        log_error(f"Download failed: {e}")
        return False


def get_audio_duration(file_path):
    """Get audio duration using ffprobe."""
    cmd = [
        'ffprobe', '-v', 'error',
        '-show_entries', 'format=duration',
        '-of', 'default=noprint_wrappers=1:nokey=1',
        str(file_path)
    ]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
        if result.returncode == 0:
            return float(result.stdout.strip())
    except Exception:
        pass

    return None


# =============================================================================
# DEMUCS
# =============================================================================
def run_demucs(input_file, output_folder, chunk_size, only_vocals=True):
    """Run Demucs with auto chunk reduction on OOM."""
    log(f"Running Demucs...")
    log(f"  Input: {input_file}")
    log(f"  Output: {output_folder}")
    log(f"  Chunk size: {chunk_size}")

    current_chunk = chunk_size
    attempt = 1

    while attempt <= MAX_ATTEMPTS:
        log(f"\n  Attempt {attempt} with chunk_size={current_chunk}...")

        # Clean partial results
        for f in Path(output_folder).glob('*'):
            if f.is_dir():
                shutil.rmtree(f)
            else:
                f.unlink()

        cmd = [
            'python3', INFERENCE_SCRIPT,
            '--input_audio', str(input_file),
            '--output_folder', str(output_folder),
            '--large_gpu',
            '--overlap_large', str(OVERLAP_LARGE),
            '--overlap_small', str(OVERLAP_SMALL),
            '--chunk_size', str(current_chunk)
        ]

        if only_vocals:
            cmd.append('--only_vocals')

        try:
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1
            )

            for line in process.stdout:
                if '%' in line or 'Processing' in line or 'Separating' in line:
                    print(f"    {line.strip()}")

            process.wait()

            if process.returncode == 0:
                log(f"  Demucs completed successfully")
                return True

        except Exception as e:
            log_error(f"Demucs exception: {e}")

        log(f"  Failed with chunk_size={current_chunk}")

        if current_chunk <= MIN_CHUNK_SIZE:
            log_error(f"Minimum chunk_size reached, cannot continue")
            break

        current_chunk = max(MIN_CHUNK_SIZE, current_chunk - CHUNK_REDUCTION)
        log(f"  Reducing chunk_size to {current_chunk}")
        attempt += 1

    log_error(f"Demucs failed after {attempt} attempts")
    return False


# =============================================================================
# MAIN
# =============================================================================
def main():
    parser = argparse.ArgumentParser(
        description='Demucs audio separation - separate vocals from instrumental',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  # From URL (public or signed)
  demucs-separate --input "https://example.com/audio.mp3" --output ./results

  # From local file
  demucs-separate --input /path/to/audio.wav --output ./results

  # Extract all stems (vocals, drums, bass, other)
  demucs-separate --input audio.mp3 --output ./results --all-stems
'''
    )

    parser.add_argument('--version', action='version', version=f'%(prog)s {__VERSION__}')
    parser.add_argument('--input', '-i', type=str, required=True,
                        help='Audio file path or URL (public/signed)')
    parser.add_argument('--output', '-o', type=str, required=True,
                        help='Output folder for results')
    parser.add_argument('--all-stems', action='store_true',
                        help='Extract all stems (vocals, drums, bass, other)')

    args = parser.parse_args()

    only_vocals = not args.all_stems

    # Check inference script
    if not os.path.exists(INFERENCE_SCRIPT):
        log_error(f"inference_demucs.py not found at {INFERENCE_SCRIPT}")
        sys.exit(1)

    # Detect GPU
    chunk_size = detect_gpu()

    # Create output directory
    output_dir = Path(args.output)
    output_dir.mkdir(parents=True, exist_ok=True)

    # Handle input
    temp_dir = None
    input_file = None

    try:
        if is_url(args.input):
            # Download from URL
            temp_dir = tempfile.mkdtemp(prefix='demucs-')

            # Determine extension from URL
            url_path = urlparse(args.input).path
            ext = Path(url_path).suffix or '.mp3'

            input_file = Path(temp_dir) / f'input{ext}'

            if not download_audio(args.input, input_file):
                sys.exit(1)
        else:
            # Local file
            input_file = Path(args.input)
            if not input_file.exists():
                log_error(f"Input file not found: {input_file}")
                sys.exit(1)

        # Get duration
        duration = get_audio_duration(input_file)
        if duration:
            minutes = int(duration // 60)
            seconds = int(duration % 60)
            log(f"Audio duration: {minutes}m {seconds}s")

        # Run Demucs
        if not run_demucs(input_file, output_dir, chunk_size, only_vocals):
            sys.exit(1)

        # Summary
        log("\n" + "=" * 50)
        log("  SEPARATION COMPLETE")
        log("=" * 50)
        log(f"  Output: {output_dir}")

        # List output files
        output_files = list(output_dir.rglob('*.mp3')) + list(output_dir.rglob('*.wav'))
        log(f"  Files created: {len(output_files)}")
        for f in output_files:
            log(f"    - {f.relative_to(output_dir)}")

    finally:
        if temp_dir:
            shutil.rmtree(temp_dir, ignore_errors=True)

    log("\nDone!")
    return 0


if __name__ == '__main__':
    sys.exit(main())
