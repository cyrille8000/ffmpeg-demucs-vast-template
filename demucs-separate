#!/usr/bin/env python3
# =============================================================================
# DEMUCS-SEPARATE CLI - Audio Separation Tool
# =============================================================================
# CLI for Demucs audio separation:
#   - Input: URL (public/signed) or local audio file
#   - Interval cutting: Split audio at specified timestamps
#   - Output: Separated audio (vocals + instrumental)
#
# Usage:
#   demucs-separate --input "https://url/audio.mp3" --output ./results
#   demucs-separate --input "https://url/audio.mp3" --interval-cut "300,600,900" --output ./results
#   demucs-separate --input "/path/to/audio.wav" --output ./results
#   demucs-separate --help
# =============================================================================

import argparse
import os
import sys
import subprocess
import tempfile
import shutil
from pathlib import Path
from urllib.parse import urlparse

__VERSION__ = '1.2.0'

# =============================================================================
# CONFIGURATION
# =============================================================================
MVSEP_DIR = '/workspace/mvsep'
INFERENCE_SCRIPT = f'{MVSEP_DIR}/inference_demucs.py'

# Audio cutting parameters
DEFAULT_SEGMENT_DURATION = 300  # 5 minutes max per segment

# Demucs parameters
MODEL_OVERHEAD = 4
SAMPLES_PER_GB = 60000
SAFETY_MARGIN = 0.9
MIN_CHUNK_SIZE = 50000
MAX_CHUNK_SIZE = 5000000
CHUNK_REDUCTION = 50000
MAX_ATTEMPTS = 20

OVERLAP_LARGE = 0.0001
OVERLAP_SMALL = 1


# =============================================================================
# LOGGING
# =============================================================================
def log(msg):
    print(f"[demucs-separate] {msg}")


def log_error(msg):
    print(f"[demucs-separate] ERROR: {msg}", file=sys.stderr)


# =============================================================================
# GPU DETECTION
# =============================================================================
def detect_gpu():
    log("Detecting GPU configuration...")

    try:
        result = subprocess.run(
            ['nvidia-smi', '--query-gpu=name', '--format=csv,noheader'],
            capture_output=True, text=True, timeout=10
        )
        gpu_name = result.stdout.strip().split('\n')[0] if result.returncode == 0 else None

        result = subprocess.run(
            ['nvidia-smi', '--query-gpu=memory.total', '--format=csv,noheader,nounits'],
            capture_output=True, text=True, timeout=10
        )
        vram_mb = int(result.stdout.strip().split('\n')[0]) if result.returncode == 0 else 0
        vram_gb = vram_mb // 1024

        if gpu_name and vram_gb > 0:
            log(f"  GPU: {gpu_name}")
            log(f"  VRAM: {vram_gb} GB")

            vram_available = max(1, vram_gb - MODEL_OVERHEAD)
            chunk_size = int(vram_available * SAMPLES_PER_GB * SAFETY_MARGIN)
            chunk_size = max(MIN_CHUNK_SIZE, min(MAX_CHUNK_SIZE, chunk_size))
            log(f"  Chunk size: {chunk_size} samples")

            return chunk_size

    except Exception as e:
        log(f"  GPU detection failed: {e}")

    log("  Using CPU mode with minimum chunk size")
    return MIN_CHUNK_SIZE


# =============================================================================
# INPUT HANDLING
# =============================================================================
def is_url(path):
    """Check if the input is a URL."""
    parsed = urlparse(path)
    return parsed.scheme in ('http', 'https')


def download_audio(url, output_path):
    """Download audio file from URL."""
    log(f"Downloading audio from: {url}")

    cmd = ['wget', '-q', '--show-progress', '-O', str(output_path), url]

    try:
        result = subprocess.run(cmd, timeout=300)
        if result.returncode != 0:
            log_error("Download failed")
            return False

        if not output_path.exists() or output_path.stat().st_size == 0:
            log_error("Downloaded file is empty or missing")
            return False

        log(f"  Downloaded: {output_path.stat().st_size / 1024 / 1024:.1f} MB")
        return True

    except subprocess.TimeoutExpired:
        log_error("Download timeout (5 min)")
        return False
    except Exception as e:
        log_error(f"Download failed: {e}")
        return False


def get_audio_duration(file_path):
    """Get audio duration using ffprobe."""
    cmd = [
        'ffprobe', '-v', 'error',
        '-show_entries', 'format=duration',
        '-of', 'default=noprint_wrappers=1:nokey=1',
        str(file_path)
    ]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
        if result.returncode == 0:
            return float(result.stdout.strip())
    except Exception:
        pass

    return None


def seconds_to_timecode(seconds):
    """Convert seconds to HH:MM:SS.ms format."""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = seconds % 60
    return f"{hours:02d}:{minutes:02d}:{secs:05.2f}"


# =============================================================================
# INTERVAL CUTTING
# =============================================================================
def parse_intervals(timestamps_str, audio_duration):
    """
    Parse timestamps and generate intervals.

    Input: "300,600,900" with audio_duration=1200
    Output: [(0, 300), (300, 600), (600, 900), (900, 1200)]
    """
    try:
        timestamps = [float(t.strip()) for t in timestamps_str.split(',') if t.strip()]

        if not timestamps:
            log_error("No valid timestamps provided")
            return None

        timestamps = sorted(timestamps)

        intervals = []
        prev = 0.0

        for ts in timestamps:
            if ts > prev:
                intervals.append((prev, ts))
                prev = ts

        # Add final segment to end of audio
        if audio_duration and audio_duration > prev:
            intervals.append((prev, audio_duration))

        return intervals

    except ValueError as e:
        log_error(f"Invalid timestamp format: {e}")
        return None


def generate_auto_intervals(audio_duration, max_segment_duration=DEFAULT_SEGMENT_DURATION):
    """
    Generate automatic intervals based on max segment duration.

    Input: audio_duration=720, max_segment_duration=300
    Output: [(0, 300), (300, 600), (600, 720)]
    """
    if audio_duration <= max_segment_duration:
        # No need to cut, single segment
        return [(0, audio_duration)]

    intervals = []
    current = 0.0

    while current < audio_duration:
        end = min(current + max_segment_duration, audio_duration)
        intervals.append((current, end))
        current = end

    return intervals


def cut_audio_segments(input_file, output_dir, intervals):
    """Cut audio into segments at specified intervals."""
    log("Cutting audio into segments...")

    segments = []
    ext = input_file.suffix

    for idx, (start, end) in enumerate(intervals):
        duration = end - start
        output_file = output_dir / f"segment_{idx:03d}{ext}"

        log(f"  Segment {idx}: {seconds_to_timecode(start)} -> {seconds_to_timecode(end)} ({duration:.1f}s)")

        cmd = [
            'ffmpeg', '-y',
            '-i', str(input_file),
            '-ss', str(start),
            '-t', str(duration),
            '-c', 'copy',
            str(output_file)
        ]

        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode == 0:
            segments.append(output_file)
        else:
            log_error(f"Failed to cut segment {idx}: {result.stderr}")

    log(f"  Created {len(segments)} audio segments")
    return segments


# =============================================================================
# DEMUCS
# =============================================================================
def run_demucs(input_files, output_folder, chunk_size, only_vocals=True):
    """Run Demucs with auto chunk reduction on OOM."""
    if isinstance(input_files, Path):
        input_files = [input_files]

    log(f"Running Demucs on {len(input_files)} file(s)...")
    log(f"  Output: {output_folder}")
    log(f"  Chunk size: {chunk_size}")

    current_chunk = chunk_size
    attempt = 1

    while attempt <= MAX_ATTEMPTS:
        log(f"\n  Attempt {attempt} with chunk_size={current_chunk}...")

        # Clean partial results
        for f in Path(output_folder).glob('*'):
            if f.is_dir():
                shutil.rmtree(f)
            else:
                f.unlink()

        cmd = [
            'python3', INFERENCE_SCRIPT,
            '--input_audio'] + [str(f) for f in input_files] + [
            '--output_folder', str(output_folder),
            '--large_gpu',
            '--overlap_large', str(OVERLAP_LARGE),
            '--overlap_small', str(OVERLAP_SMALL),
            '--chunk_size', str(current_chunk)
        ]

        if only_vocals:
            cmd.append('--only_vocals')

        try:
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1
            )

            for line in process.stdout:
                if '%' in line or 'Processing' in line or 'Separating' in line:
                    print(f"    {line.strip()}")

            process.wait()

            if process.returncode == 0:
                log(f"  Demucs completed successfully")
                return True

        except Exception as e:
            log_error(f"Demucs exception: {e}")

        log(f"  Failed with chunk_size={current_chunk}")

        if current_chunk <= MIN_CHUNK_SIZE:
            log_error(f"Minimum chunk_size reached, cannot continue")
            break

        current_chunk = max(MIN_CHUNK_SIZE, current_chunk - CHUNK_REDUCTION)
        log(f"  Reducing chunk_size to {current_chunk}")
        attempt += 1

    log_error(f"Demucs failed after {attempt} attempts")
    return False


# =============================================================================
# MAIN
# =============================================================================
def main():
    parser = argparse.ArgumentParser(
        description='Demucs audio separation - separate vocals from instrumental',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  # From URL - auto-cuts into 5min segments
  demucs-separate --input "https://example.com/audio.mp3" --output ./results

  # With custom intervals (timestamps in seconds)
  # Creates segments: [0->300s], [300s->600s], [600s->900s], [900s->END]
  demucs-separate --input "https://..." --interval-cut "300,600,900" --output ./results

  # From local file
  demucs-separate --input /path/to/audio.wav --output ./results

  # Extract all stems (vocals, drums, bass, other)
  demucs-separate --input audio.mp3 --output ./results --all-stems

Note: By default, audio files are automatically split into 5-minute segments.
      Use --interval-cut to specify custom cut points.
'''
    )

    parser.add_argument('--version', action='version', version=f'%(prog)s {__VERSION__}')
    parser.add_argument('--input', '-i', type=str, required=True,
                        help='Audio file path or URL (public/signed)')
    parser.add_argument('--output', '-o', type=str, required=True,
                        help='Output folder for results')
    parser.add_argument('--interval-cut', type=str,
                        help='Timestamps in seconds to cut audio (e.g., "300,600,900")')
    parser.add_argument('--all-stems', action='store_true',
                        help='Extract all stems (vocals, drums, bass, other)')

    args = parser.parse_args()

    only_vocals = not args.all_stems

    # Check inference script
    if not os.path.exists(INFERENCE_SCRIPT):
        log_error(f"inference_demucs.py not found at {INFERENCE_SCRIPT}")
        sys.exit(1)

    # Detect GPU
    chunk_size = detect_gpu()

    # Create output directory
    output_dir = Path(args.output)
    output_dir.mkdir(parents=True, exist_ok=True)

    # Handle input
    temp_dir = None
    input_file = None

    try:
        if is_url(args.input):
            # Download from URL
            temp_dir = tempfile.mkdtemp(prefix='demucs-')

            # Determine extension from URL
            url_path = urlparse(args.input).path
            ext = Path(url_path).suffix or '.mp3'

            input_file = Path(temp_dir) / f'input{ext}'

            if not download_audio(args.input, input_file):
                sys.exit(1)
        else:
            # Local file
            input_file = Path(args.input)
            if not input_file.exists():
                log_error(f"Input file not found: {input_file}")
                sys.exit(1)

        # Get duration
        duration = get_audio_duration(input_file)
        if duration:
            minutes = int(duration // 60)
            seconds = int(duration % 60)
            log(f"Audio duration: {minutes}m {seconds}s")

        # Handle interval cutting
        files_to_process = []
        segments_dir = output_dir / 'segments'

        if args.interval_cut:
            log("\nParsing custom intervals...")
            intervals = parse_intervals(args.interval_cut, duration)

            if intervals is None:
                sys.exit(1)
        else:
            # Auto-generate intervals (max 5 min per segment)
            log(f"\nAuto-generating intervals (max {DEFAULT_SEGMENT_DURATION}s per segment)...")
            intervals = generate_auto_intervals(duration)

        log(f"  {len(intervals)} segment(s) to process")
        for idx, (start, end) in enumerate(intervals):
            log(f"    [{idx}] {seconds_to_timecode(start)} -> {seconds_to_timecode(end)} ({end-start:.1f}s)")

        # Cut audio if more than 1 segment
        if len(intervals) > 1:
            segments_dir.mkdir(parents=True, exist_ok=True)
            files_to_process = cut_audio_segments(input_file, segments_dir, intervals)

            if not files_to_process:
                log_error("No segments created")
                sys.exit(1)
        else:
            # Single segment, process full file
            files_to_process = [input_file]

        # Run Demucs
        demucs_output = output_dir / 'demucs_results'
        demucs_output.mkdir(parents=True, exist_ok=True)

        if not run_demucs(files_to_process, demucs_output, chunk_size, only_vocals):
            sys.exit(1)

        # Summary
        log("\n" + "=" * 50)
        log("  SEPARATION COMPLETE")
        log("=" * 50)
        log(f"  Output: {output_dir}")

        if len(intervals) > 1:
            log(f"  Segments: {segments_dir} ({len(intervals)} files)")

        log(f"  Demucs results: {demucs_output}")

        # List output files
        output_files = list(demucs_output.rglob('*.mp3')) + list(demucs_output.rglob('*.wav'))
        log(f"  Files created: {len(output_files)}")

    finally:
        if temp_dir:
            shutil.rmtree(temp_dir, ignore_errors=True)

    log("\nDone!")
    return 0


if __name__ == '__main__':
    sys.exit(main())
