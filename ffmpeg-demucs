#!/usr/bin/env python3
# =============================================================================
# FFMPEG-DEMUCS CLI - Complete Video/Audio Separation Pipeline
# =============================================================================
# A unified CLI tool implementing the full workflow from demucsServe.sh:
#   1. Download video 720p from YouTube
#   2. Convert to 240p (GPU cascade: CUDA -> NVENC -> CPU)
#   3. Extract audio (mono, 192k, 44100Hz)
#   4. User-provided intervals (or full file)
#   5. Encode video with forced keyframes at intervals
#   6. Cut video at keyframes without re-encoding
#   7. Cut audio at intervals
#   8. Run Demucs with auto chunk reduction
#   9. Verify audio/video durations match
#
# Usage:
#   ffmpeg-demucs --input-url-youtube "https://..." --output ./results
#   ffmpeg-demucs --input-file video.mp4 --output ./results
#   ffmpeg-demucs --input-url-youtube "https://..." --interval-cut "5.6,475.1,800.5" --output ./results
#
# =============================================================================

import argparse
import os
import sys
import subprocess
import tempfile
import shutil
from pathlib import Path


__VERSION__ = '2.0.0'

# =============================================================================
# CONFIGURATION (from demucsServe.sh)
# =============================================================================
MVSEP_DIR = '/workspace/mvsep'
INFERENCE_SCRIPT = f'{MVSEP_DIR}/inference_demucs.py'

# Audio parameters
SAMPLE_RATE = 44100
AUDIO_BITRATE = '192k'
AUDIO_CHANNELS = 1  # mono

# Demucs parameters
MODEL_OVERHEAD = 4        # GB for Demucs model
SAMPLES_PER_GB = 60000    # samples per available GB
SAFETY_MARGIN = 0.9       # 90% safety margin
MIN_CHUNK_SIZE = 50000
MAX_CHUNK_SIZE = 5000000
CHUNK_REDUCTION = 50000
MAX_ATTEMPTS = 20

# Demucs inference parameters (from demucsServe.sh)
OVERLAP_LARGE = 0.0001
OVERLAP_SMALL = 1


# =============================================================================
# LOGGING
# =============================================================================
def log(msg, prefix='ffmpeg-demucs'):
    """Print log message with prefix."""
    print(f"[{prefix}] {msg}")


def log_error(msg):
    """Print error message."""
    print(f"[ffmpeg-demucs] ERROR: {msg}", file=sys.stderr)


def log_step(step_num, total, msg):
    """Print step progress."""
    print(f"\n[{step_num}/{total}] {msg}")


# =============================================================================
# DEPENDENCY CHECKS
# =============================================================================
def check_dependencies():
    """Check if required tools are available."""
    missing = []

    # Check yt-dlp
    if shutil.which('yt-dlp') is None:
        missing.append('yt-dlp')

    # Check ffmpeg
    if shutil.which('ffmpeg') is None:
        missing.append('ffmpeg')

    # Check ffprobe
    if shutil.which('ffprobe') is None:
        missing.append('ffprobe')

    # Check inference script
    if not os.path.exists(INFERENCE_SCRIPT):
        missing.append(f'inference_demucs.py (expected at {INFERENCE_SCRIPT})')

    return missing


def has_encoder(encoder_name):
    """Check if FFmpeg has a specific encoder."""
    try:
        result = subprocess.run(
            ['ffmpeg', '-hide_banner', '-encoders'],
            capture_output=True, text=True, timeout=10
        )
        return encoder_name in result.stdout
    except Exception:
        return False


# =============================================================================
# GPU DETECTION (from demucsServe.sh)
# =============================================================================
def detect_gpu():
    """Detect GPU and calculate optimal chunk size."""
    log("Detecting GPU configuration...")

    try:
        # Get GPU name
        result = subprocess.run(
            ['nvidia-smi', '--query-gpu=name', '--format=csv,noheader'],
            capture_output=True, text=True, timeout=10
        )
        gpu_name = result.stdout.strip().split('\n')[0] if result.returncode == 0 else None

        # Get VRAM
        result = subprocess.run(
            ['nvidia-smi', '--query-gpu=memory.total', '--format=csv,noheader,nounits'],
            capture_output=True, text=True, timeout=10
        )
        vram_mb = int(result.stdout.strip().split('\n')[0]) if result.returncode == 0 else 0
        vram_gb = vram_mb // 1024

        if gpu_name and vram_gb > 0:
            log(f"  GPU: {gpu_name}")
            log(f"  VRAM: {vram_gb} GB")

            # Calculate chunk size (formula from demucsServe.sh)
            vram_available = max(1, vram_gb - MODEL_OVERHEAD)
            chunk_size = int(vram_available * SAMPLES_PER_GB * SAFETY_MARGIN)

            chunk_size = max(MIN_CHUNK_SIZE, min(MAX_CHUNK_SIZE, chunk_size))
            log(f"  Chunk size: {chunk_size} samples")

            return {
                'gpu_name': gpu_name,
                'vram_gb': vram_gb,
                'chunk_size': chunk_size,
                'nvenc_available': True
            }

    except Exception as e:
        log(f"  GPU detection failed: {e}")

    log("  Using CPU mode")
    return {
        'gpu_name': None,
        'vram_gb': 0,
        'chunk_size': MIN_CHUNK_SIZE,
        'nvenc_available': False
    }


def check_nvenc():
    """Test if NVENC is actually functional."""
    try:
        result = subprocess.run(
            ['ffmpeg', '-f', 'lavfi', '-i', 'testsrc=duration=0.5:size=256x256:rate=1',
             '-c:v', 'h264_nvenc', '-f', 'null', '-'],
            capture_output=True, text=True, timeout=30
        )
        return result.returncode == 0 and 'video:' in result.stderr
    except Exception:
        return False


# =============================================================================
# COOKIE DOWNLOAD
# =============================================================================
def download_cookies(url, output_path):
    """Download cookies file from a public URL."""
    log("Downloading cookies file...")

    cmd = ['wget', '-q', '-O', str(output_path), url]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
        if result.returncode != 0:
            log_error(f"Failed to download cookies: {result.stderr}")
            return False

        # Verify it's a valid text file
        with open(output_path, 'r') as f:
            first_line = f.readline()
            if 'Netscape' not in first_line and 'Cookie' not in first_line:
                log("  Note: Cookie file doesn't have standard Netscape header")

        log("  Cookies file downloaded")
        return True
    except Exception as e:
        log_error(f"Failed to download cookies: {e}")
        return False


# =============================================================================
# YOUTUBE VIDEO DOWNLOAD (720p video, not just audio)
# =============================================================================
def download_youtube_video(url, output_path, cookies_file=None):
    """Download VIDEO from YouTube at 720p max."""
    log(f"Downloading video from YouTube: {url}")
    log("  Format: best[height<=720]/best (video)")

    cmd = [
        'yt-dlp',
        '-f', 'best[height<=720]/best',  # Video 720p max
        '-o', str(output_path),
        url
    ]

    if cookies_file and os.path.exists(cookies_file):
        cmd.extend(['--cookies', cookies_file])
        log(f"  Using cookies file: {cookies_file}")

    try:
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1
        )

        for line in process.stdout:
            if '[download]' in line:
                print(f"  {line.strip()}")

        process.wait()

        if process.returncode != 0:
            log_error("yt-dlp download failed")
            return False

        log("Video download completed")
        return True
    except Exception as e:
        log_error(f"Download failed: {e}")
        return False


# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================
def seconds_to_timecode(seconds):
    """Convert seconds to HH:MM:SS.ms format."""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = seconds % 60
    return f"{hours:02d}:{minutes:02d}:{secs:05.2f}"


def get_media_duration(file_path):
    """Get media duration in seconds using ffprobe."""
    cmd = [
        'ffprobe',
        '-v', 'error',
        '-show_entries', 'format=duration',
        '-of', 'default=noprint_wrappers=1:nokey=1',
        str(file_path)
    ]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
        if result.returncode == 0:
            return float(result.stdout.strip())
    except Exception:
        pass

    return None


def parse_timestamps_to_intervals(timestamps_str, audio_duration=None):
    """
    Parse timestamps in seconds and generate intervals.

    Input: "5.6,475.1,800.5" with audio_duration=1000
    Output: [(0, 5.6), (5.6, 475.1), (475.1, 800.5), (800.5, 1000)]
    """
    try:
        timestamps = [float(t.strip()) for t in timestamps_str.split(',') if t.strip()]

        if not timestamps:
            log_error("No valid timestamps provided")
            return None

        timestamps = sorted(timestamps)

        intervals = []
        prev = 0.0

        for ts in timestamps:
            if ts > prev:
                intervals.append((prev, ts))
                log(f"  Interval: {seconds_to_timecode(prev)} -> {seconds_to_timecode(ts)}")
                prev = ts

        if audio_duration and audio_duration > prev:
            intervals.append((prev, audio_duration))
            log(f"  Interval: {seconds_to_timecode(prev)} -> {seconds_to_timecode(audio_duration)} (end of file)")

        if not intervals:
            log_error("No valid intervals could be generated")
            return None

        return intervals

    except ValueError as e:
        log_error(f"Invalid timestamp format: {e}")
        log_error("Expected format: '5.6,475.1,800.5' (seconds with decimals)")
        return None


# =============================================================================
# STEP 1: ENCODE VIDEO TO 240P (GPU cascade from demucsServe.sh)
# =============================================================================
def encode_video_240p(input_path, output_path, nvenc_available=False):
    """Encode video to 240p using GPU cascade."""
    log("Encoding video to 240p...")

    # Method 1: GPU complete (decode + scale + encode on GPU)
    if nvenc_available:
        log("  Trying GPU complete (CUDA + scale_cuda + NVENC)...")
        cmd = [
            'ffmpeg', '-y',
            '-hwaccel', 'cuda', '-hwaccel_output_format', 'cuda',
            '-i', str(input_path),
            '-vf', 'scale_cuda=-2:240',
            '-c:v', 'h264_nvenc',
            '-preset', 'p4',
            '-rc', 'vbr',
            '-cq', '30',
            '-profile:v', 'main',
            '-movflags', '+faststart',
            '-an',
            str(output_path)
        ]

        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode == 0:
            log("  GPU complete encoding success")
            return True

        # Method 2: NVENC only (decode CPU, encode GPU)
        log("  GPU complete failed, trying NVENC only...")
        cmd = [
            'ffmpeg', '-y',
            '-i', str(input_path),
            '-vf', 'scale=-2:240',
            '-c:v', 'h264_nvenc',
            '-preset', 'p4',
            '-rc', 'vbr',
            '-cq', '30',
            '-profile:v', 'main',
            '-movflags', '+faststart',
            '-an',
            str(output_path)
        ]

        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode == 0:
            log("  NVENC encoding success")
            return True

    # Method 3: CPU fallback
    log("  Using CPU encoding (libx264)...")
    cmd = [
        'ffmpeg', '-y',
        '-i', str(input_path),
        '-vf', 'scale=-2:240',
        '-c:v', 'libx264',
        '-preset', 'fast',
        '-crf', '30',
        '-profile:v', 'main',
        '-movflags', '+faststart',
        '-an',
        str(output_path)
    ]

    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode == 0:
        log("  CPU encoding success")
        return True

    log_error(f"Video 240p encoding failed: {result.stderr}")
    return False


# =============================================================================
# STEP 2: EXTRACT AUDIO (from demucsServe.sh)
# =============================================================================
def extract_audio(input_path, output_path):
    """Extract audio from video (mono, 192k, 44100Hz)."""
    log(f"Extracting audio: mono, {AUDIO_BITRATE}, {SAMPLE_RATE}Hz")

    cmd = [
        'ffmpeg', '-y',
        '-i', str(input_path),
        '-vn',
        '-ac', str(AUDIO_CHANNELS),
        '-acodec', 'libmp3lame',
        '-ab', AUDIO_BITRATE,
        '-ar', str(SAMPLE_RATE),
        str(output_path)
    ]

    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode == 0:
        log("  Audio extraction complete")
        return True

    log_error(f"Audio extraction failed: {result.stderr}")
    return False


# =============================================================================
# STEP 3: ENCODE VIDEO WITH FORCED KEYFRAMES (from demucsServe.sh)
# =============================================================================
def encode_with_keyframes(input_path, output_base, timestamps, nvenc_available=False):
    """
    Encode video with forced keyframes at specified timestamps.
    Cascade: AV1 GPU -> H.264 GPU -> VP9 CPU -> H.264 CPU
    Returns (output_path, format) or (None, None) on failure.
    """
    log("Encoding video with forced keyframes...")

    if not timestamps:
        log("  No timestamps, copying file...")
        output_path = f"{output_base}.mp4"
        shutil.copy(input_path, output_path)
        return output_path, 'mp4'

    keyframe_times = ','.join(str(t) for t in timestamps)
    log(f"  Keyframes at: {keyframe_times}")

    # Detect available encoders
    has_av1_nvenc = has_encoder('av1_nvenc')
    has_h264_nvenc = has_encoder('h264_nvenc')
    has_vp9 = has_encoder('libvpx-vp9')
    has_h264 = has_encoder('libx264')

    log(f"  Encoders: av1_nvenc={has_av1_nvenc}, h264_nvenc={has_h264_nvenc}, vp9={has_vp9}, h264={has_h264}")

    # Attempt 1: AV1 GPU -> WebM
    if has_av1_nvenc and nvenc_available:
        log("  Trying AV1 GPU (av1_nvenc) -> WebM...")
        output_path = f"{output_base}.webm"
        cmd = [
            'ffmpeg', '-y',
            '-hwaccel', 'cuda', '-hwaccel_output_format', 'cuda',
            '-i', str(input_path),
            '-c:v', 'av1_nvenc',
            '-preset', 'p1',
            '-rc', 'constqp',
            '-qp', '30',
            '-c:a', 'libopus',
            '-b:a', '128k',
            '-ar', '48000',
            '-g', '999999',
            '-forced-idr', '1',
            '-force_key_frames:v', keyframe_times,
            output_path
        ]
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode == 0:
            log("  AV1 GPU success")
            return output_path, 'webm'

    # Attempt 2: H.264 GPU -> MP4
    if has_h264_nvenc and nvenc_available:
        log("  Trying H.264 GPU (h264_nvenc) -> MP4...")
        output_path = f"{output_base}.mp4"

        # Try with hwaccel
        cmd = [
            'ffmpeg', '-y',
            '-hwaccel', 'cuda', '-hwaccel_output_format', 'cuda',
            '-i', str(input_path),
            '-c:v', 'h264_nvenc',
            '-preset', 'p1',
            '-rc', 'constqp',
            '-qp', '23',
            '-c:a', 'aac',
            '-b:a', '128k',
            '-ar', '44100',
            '-video_track_timescale', '90000',
            '-g', '999999',
            '-forced-idr', '1',
            '-force_key_frames:v', keyframe_times,
            '-movflags', '+faststart',
            output_path
        ]
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode == 0:
            log("  H.264 GPU success")
            return output_path, 'mp4'

        # Retry without hwaccel
        log("  Retrying NVENC without hwaccel...")
        cmd = [
            'ffmpeg', '-y',
            '-i', str(input_path),
            '-c:v', 'h264_nvenc',
            '-preset', 'p1',
            '-rc', 'constqp',
            '-qp', '23',
            '-c:a', 'aac',
            '-b:a', '128k',
            '-ar', '44100',
            '-video_track_timescale', '90000',
            '-g', '999999',
            '-forced-idr', '1',
            '-force_key_frames:v', keyframe_times,
            '-movflags', '+faststart',
            output_path
        ]
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode == 0:
            log("  H.264 NVENC (CPU decode) success")
            return output_path, 'mp4'

    # Attempt 3: VP9 CPU -> WebM
    if has_vp9:
        log("  Trying VP9 CPU (libvpx-vp9) -> WebM...")
        output_path = f"{output_base}.webm"
        cmd = [
            'ffmpeg', '-y',
            '-i', str(input_path),
            '-c:v', 'libvpx-vp9',
            '-crf', '35',
            '-b:v', '0',
            '-cpu-used', '4',
            '-row-mt', '1',
            '-c:a', 'libopus',
            '-b:a', '128k',
            '-ar', '48000',
            '-g', '999999',
            '-force_key_frames:v', keyframe_times,
            output_path
        ]
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode == 0:
            log("  VP9 CPU success")
            return output_path, 'webm'

    # Attempt 4: H.264 CPU -> MP4 (fallback)
    if has_h264:
        log("  Trying H.264 CPU (libx264) -> MP4...")
        output_path = f"{output_base}.mp4"
        cmd = [
            'ffmpeg', '-y',
            '-i', str(input_path),
            '-c:v', 'libx264',
            '-preset', 'ultrafast',
            '-crf', '23',
            '-c:a', 'aac',
            '-b:a', '128k',
            '-ar', '44100',
            '-video_track_timescale', '90000',
            '-x264-params', 'keyint=999999:min-keyint=1:scenecut=0:force-cfr=1',
            '-g', '999999',
            '-sc_threshold', '0',
            '-force_key_frames:v', keyframe_times,
            '-movflags', '+faststart',
            '-threads', '0',
            output_path
        ]
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode == 0:
            log("  H.264 CPU success")
            return output_path, 'mp4'

    log_error("All encoders failed")
    return None, None


# =============================================================================
# STEP 4: CUT VIDEO AT KEYFRAMES (from demucsServe.sh)
# =============================================================================
def get_keyframes(video_path):
    """Extract list of keyframe timestamps from video."""
    cmd = [
        'ffprobe', '-v', 'error',
        '-select_streams', 'v:0',
        '-show_entries', 'packet=pts_time,flags',
        '-of', 'csv=p=0',
        str(video_path)
    ]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
        keyframes = []
        for line in result.stdout.strip().split('\n'):
            if ',K' in line:
                pts = line.split(',')[0]
                if pts:
                    keyframes.append(float(pts))
        return keyframes
    except Exception as e:
        log_error(f"Failed to extract keyframes: {e}")
        return []


def find_closest_keyframe(keyframes, target):
    """Find the keyframe closest to the target timestamp."""
    if not keyframes:
        return target

    closest = keyframes[0]
    min_diff = abs(keyframes[0] - target)

    for kf in keyframes:
        diff = abs(kf - target)
        if diff < min_diff:
            min_diff = diff
            closest = kf

    return closest


def cut_video_at_keyframes(input_path, output_dir, intervals):
    """Cut video at keyframes without re-encoding."""
    log("Cutting video at keyframes (no re-encoding)...")

    ext = Path(input_path).suffix

    # Get all keyframes
    keyframes = get_keyframes(input_path)
    log(f"  Found {len(keyframes)} keyframes")

    # Get video duration
    duration = get_media_duration(input_path)

    segments = []
    for idx, (start, end) in enumerate(intervals):
        # Align to closest keyframes
        aligned_start = find_closest_keyframe(keyframes, start) if start > 0 else 0
        aligned_end = find_closest_keyframe(keyframes, end) if end < duration else duration

        seg_duration = aligned_end - aligned_start
        output_file = Path(output_dir) / f"segment_{idx:03d}{ext}"

        log(f"  Segment {idx}: {aligned_start:.2f}s -> {aligned_end:.2f}s (duration: {seg_duration:.2f}s)")

        cmd = [
            'ffmpeg', '-y',
            '-ss', str(aligned_start),
            '-i', str(input_path),
            '-t', str(seg_duration),
            '-c', 'copy',
            '-avoid_negative_ts', 'make_zero',
            str(output_file)
        ]

        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode == 0:
            segments.append(output_file)
        else:
            log_error(f"Failed to cut segment {idx}")

    log(f"  Created {len(segments)} video segments")
    return segments


# =============================================================================
# STEP 5: CUT AUDIO AT INTERVALS
# =============================================================================
def cut_audio_at_intervals(input_path, output_dir, intervals):
    """Cut audio at specified intervals."""
    log("Cutting audio at intervals...")

    segments = []
    for idx, (start, end) in enumerate(intervals):
        duration = end - start
        output_file = Path(output_dir) / f"segment_{idx:03d}.mp3"

        log(f"  Segment {idx}: {start:.2f}s -> {end:.2f}s (duration: {duration:.2f}s)")

        cmd = [
            'ffmpeg', '-y',
            '-i', str(input_path),
            '-ss', str(start),
            '-t', str(duration),
            '-c:a', 'copy',
            str(output_file)
        ]

        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode == 0:
            segments.append(output_file)
        else:
            log_error(f"Failed to cut audio segment {idx}")

    log(f"  Created {len(segments)} audio segments")
    return segments


# =============================================================================
# STEP 6: RUN DEMUCS (from demucsServe.sh with auto chunk reduction)
# =============================================================================
def run_demucs(input_files, output_folder, chunk_size, only_vocals=True):
    """
    Run Demucs inference with auto chunk reduction on OOM.
    Parameters from demucsServe.sh: --large_gpu --overlap_large 0.0001 --overlap_small 1
    """
    log(f"Running Demucs on {len(input_files)} file(s)...")
    log(f"  Initial chunk_size: {chunk_size}")
    log(f"  Parameters: --large_gpu --overlap_large {OVERLAP_LARGE} --overlap_small {OVERLAP_SMALL}")

    current_chunk = chunk_size
    attempt = 1

    while attempt <= MAX_ATTEMPTS:
        log(f"\n  Attempt {attempt} with chunk_size={current_chunk}...")

        # Clean partial results
        for f in Path(output_folder).glob('*'):
            if f.is_dir():
                shutil.rmtree(f)
            else:
                f.unlink()

        # Build command
        cmd = [
            'python3', INFERENCE_SCRIPT,
            '--input_audio'] + [str(f) for f in input_files] + [
            '--output_folder', str(output_folder),
            '--large_gpu',
            '--overlap_large', str(OVERLAP_LARGE),
            '--overlap_small', str(OVERLAP_SMALL),
            '--chunk_size', str(current_chunk)
        ]

        if only_vocals:
            cmd.append('--only_vocals')

        try:
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1
            )

            for line in process.stdout:
                # Show progress lines
                if '%' in line or 'Processing' in line or 'Separating' in line:
                    print(f"    {line.strip()}")

            process.wait()

            if process.returncode == 0:
                log(f"  Demucs completed successfully with chunk_size={current_chunk}")
                return True

        except Exception as e:
            log_error(f"Demucs exception: {e}")

        # Failed, reduce chunk size
        log(f"  Failed with chunk_size={current_chunk}")

        if current_chunk <= MIN_CHUNK_SIZE:
            log_error(f"Minimum chunk_size ({MIN_CHUNK_SIZE}) reached, cannot continue")
            break

        current_chunk = max(MIN_CHUNK_SIZE, current_chunk - CHUNK_REDUCTION)
        log(f"  Reducing chunk_size to {current_chunk}")
        attempt += 1

    log_error(f"Demucs failed after {attempt} attempts")
    return False


# =============================================================================
# STEP 7: VERIFY SEGMENT DURATIONS (from demucsServe.sh)
# =============================================================================
def verify_durations(audio_dir, video_dir):
    """Compare audio and video segment durations."""
    log("\nVerifying audio vs video durations...")

    audio_files = sorted(Path(audio_dir).glob('segment_*.mp3'))
    video_files = sorted(list(Path(video_dir).glob('segment_*.mp4')) +
                         list(Path(video_dir).glob('segment_*.webm')))

    if not audio_files or not video_files:
        log("  No segments to compare")
        return True

    count = min(len(audio_files), len(video_files))
    max_diff = 0
    errors = 0

    log(f"  Comparing {count} segment pairs...")
    log("")
    log("  Segment |   Audio (s)  |   Video (s)  |   Diff (ms)  | Status")
    log("  --------|--------------|--------------|--------------|-------")

    for i in range(count):
        audio_dur = get_media_duration(audio_files[i]) or 0
        video_dur = get_media_duration(video_files[i]) or 0

        diff_ms = abs(audio_dur - video_dur) * 1000

        if diff_ms > max_diff:
            max_diff = diff_ms

        status = "OK" if diff_ms <= 100 else ("WARN" if diff_ms <= 500 else "ERROR")
        if diff_ms > 100:
            errors += 1

        log(f"  {i:7d} | {audio_dur:12.3f} | {video_dur:12.3f} | {diff_ms:12.2f} | {status}")

    log("")
    log(f"  Max difference: {max_diff:.2f}ms")
    log(f"  Segments with diff > 100ms: {errors}")

    if errors == 0:
        log("  All durations match")
        return True
    else:
        log(f"  Warning: {errors} segments with duration mismatch")
        return False


# =============================================================================
# MAIN PIPELINE
# =============================================================================
def main():
    parser = argparse.ArgumentParser(
        description='FFmpeg + Demucs complete video/audio separation pipeline',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  # Download from YouTube and process full file
  ffmpeg-demucs --input-url-youtube "https://youtube.com/watch?v=xxx" --output ./results

  # Process local video file
  ffmpeg-demucs --input-file video.mp4 --output ./results

  # With cookies (for age-restricted videos) - URL to cookies file
  ffmpeg-demucs --input-url-youtube "https://..." --file-cookie "https://example.com/cookies.txt" --output ./results

  # Process specific intervals (timestamps in seconds)
  # Input: "5.6,475.1,800.5" generates intervals: [0->5.6s], [5.6s->475.1s], [475.1s->800.5s], [800.5s->END]
  ffmpeg-demucs --input-url-youtube "https://..." --interval-cut "5.6,475.1,800.5" --output ./results

  # Audio separation only (faster, no video processing)
  ffmpeg-demucs --input-file audio.mp3 --audio-only --output ./results
'''
    )

    parser.add_argument('--version', action='version', version=f'%(prog)s {__VERSION__}')

    # Input sources
    input_group = parser.add_mutually_exclusive_group(required=True)
    input_group.add_argument('--input-url-youtube', '-u', type=str,
                             help='YouTube URL to download and process')
    input_group.add_argument('--input-file', '-i', type=str,
                             help='Local video/audio file to process')

    # Options
    parser.add_argument('--file-cookie', '-c', type=str,
                        help='Public URL to cookie file (Netscape format) for yt-dlp')
    parser.add_argument('--interval-cut', type=str,
                        help='Timestamps in seconds (e.g., "5.6,475.1,800.5")')
    parser.add_argument('--output', '-o', type=str, required=True,
                        help='Output folder for results')

    # Processing options
    parser.add_argument('--audio-only', action='store_true',
                        help='Only process audio (skip video encoding/cutting)')
    parser.add_argument('--only-vocals', action='store_true', default=True,
                        help='Only extract vocals and instrumental (default: True)')
    parser.add_argument('--all-stems', action='store_true',
                        help='Extract all stems (vocals, drums, bass, other)')

    # Advanced
    parser.add_argument('--keep-temp', action='store_true',
                        help='Keep temporary files (for debugging)')
    parser.add_argument('--skip-demucs', action='store_true',
                        help='Skip Demucs processing (only encode/cut)')

    args = parser.parse_args()

    # Determine only_vocals
    only_vocals = not args.all_stems

    # Check dependencies
    missing = check_dependencies()
    if missing:
        log_error(f"Missing dependencies: {', '.join(missing)}")
        sys.exit(1)

    # Detect GPU
    gpu_info = detect_gpu()
    nvenc_available = gpu_info['nvenc_available'] and check_nvenc()
    chunk_size = gpu_info['chunk_size']

    if nvenc_available:
        log("NVENC encoding available")
    else:
        log("NVENC not available, using CPU encoding")

    # Create output directory
    output_dir = Path(args.output)
    output_dir.mkdir(parents=True, exist_ok=True)

    # Create subdirectories
    (output_dir / 'audio_segments').mkdir(exist_ok=True)
    (output_dir / 'video_segments').mkdir(exist_ok=True)
    (output_dir / 'demucs_results').mkdir(exist_ok=True)

    # Create temp directory
    temp_dir = tempfile.mkdtemp(prefix='ffmpeg-demucs-')
    log(f"Temp directory: {temp_dir}")

    try:
        total_steps = 9 if not args.audio_only else 5
        current_step = 0
        cookies_path = None

        # Step 0: Download cookies if URL provided
        if args.file_cookie:
            current_step += 1
            log_step(current_step, total_steps, "Downloading cookies file...")
            cookies_path = Path(temp_dir) / 'cookies.txt'
            if not download_cookies(args.file_cookie, cookies_path):
                sys.exit(1)

        # Step 1: Get input video/audio
        current_step += 1
        if args.input_url_youtube:
            log_step(current_step, total_steps, "Downloading video from YouTube (720p)...")
            download_path = Path(temp_dir) / 'source_video.mp4'
            if not download_youtube_video(args.input_url_youtube, download_path, cookies_path):
                sys.exit(1)

            # Find downloaded file
            downloaded_files = list(Path(temp_dir).glob('source_video.*'))
            if not downloaded_files:
                log_error("No downloaded file found")
                sys.exit(1)
            source_file = downloaded_files[0]
            log(f"Downloaded: {source_file}")
        else:
            source_file = Path(args.input_file)
            if not source_file.exists():
                log_error(f"Input file not found: {source_file}")
                sys.exit(1)
            log(f"Input file: {source_file}")

        # Get source duration
        source_duration = get_media_duration(source_file)
        if source_duration:
            log(f"Source duration: {seconds_to_timecode(source_duration)}")

        # Parse intervals if provided
        intervals = None
        if args.interval_cut:
            log("\nGenerating intervals from timestamps...")
            intervals = parse_timestamps_to_intervals(args.interval_cut, source_duration)
            if intervals is None:
                sys.exit(1)
        else:
            # Full file as single interval
            if source_duration:
                intervals = [(0, source_duration)]
                log(f"Processing full file: 0 -> {seconds_to_timecode(source_duration)}")

        # Get timestamps for keyframes (start of each interval except first)
        keyframe_timestamps = [interval[0] for interval in intervals[1:]] if intervals else []

        if not args.audio_only:
            # Step 2: Encode video to 240p
            current_step += 1
            log_step(current_step, total_steps, "Encoding video to 240p...")
            video_240p = Path(temp_dir) / 'video_240p.mp4'
            if not encode_video_240p(source_file, video_240p, nvenc_available):
                sys.exit(1)

        # Step 3: Extract audio
        current_step += 1
        log_step(current_step, total_steps, "Extracting audio (mono, 192k, 44100Hz)...")
        audio_file = Path(temp_dir) / 'audio.mp3'
        if not extract_audio(source_file, audio_file):
            sys.exit(1)

        if not args.audio_only:
            # Step 4: Encode video with keyframes
            current_step += 1
            log_step(current_step, total_steps, "Encoding video with forced keyframes...")
            video_keyframes_base = Path(temp_dir) / 'video_keyframes'
            video_keyframes, video_format = encode_with_keyframes(
                video_240p, str(video_keyframes_base), keyframe_timestamps, nvenc_available
            )
            if video_keyframes is None:
                sys.exit(1)
            log(f"  Video format: {video_format}")

            # Step 5: Cut video at keyframes
            current_step += 1
            log_step(current_step, total_steps, "Cutting video at keyframes...")
            cut_video_at_keyframes(
                video_keyframes, output_dir / 'video_segments', intervals
            )

        # Step 6: Cut audio at intervals
        current_step += 1
        log_step(current_step, total_steps, "Cutting audio at intervals...")
        audio_segments = cut_audio_at_intervals(
            audio_file, output_dir / 'audio_segments', intervals
        )

        # Step 7: Run Demucs
        if not args.skip_demucs:
            current_step += 1
            log_step(current_step, total_steps, "Running Demucs audio separation...")
            if not run_demucs(
                audio_segments,
                output_dir / 'demucs_results',
                chunk_size,
                only_vocals=only_vocals
            ):
                log_error("Demucs processing failed")
                sys.exit(1)

        # Step 8: Verify durations
        if not args.audio_only:
            current_step += 1
            log_step(current_step, total_steps, "Verifying segment durations...")
            verify_durations(output_dir / 'audio_segments', output_dir / 'video_segments')

        # Summary
        log("\n" + "=" * 60)
        log("  PROCESSING COMPLETE")
        log("=" * 60)
        log("")
        log(f"  Output directory: {output_dir}")
        log("")
        log("  Structure:")
        log("    audio_segments/       - Audio segments (MP3)")
        if not args.audio_only:
            log(f"    video_segments/       - Video segments ({video_format.upper()})")
        log("    demucs_results/       - Separated audio (vocals/instruments)")
        log("")

        # List output files
        audio_count = len(list((output_dir / 'audio_segments').glob('*.mp3')))
        if not args.audio_only:
            video_count = len(list((output_dir / 'video_segments').glob('*.*')))
        demucs_count = len(list((output_dir / 'demucs_results').rglob('*.mp3')))

        log(f"  Files created:")
        log(f"    Audio segments: {audio_count}")
        if not args.audio_only:
            log(f"    Video segments: {video_count}")
        log(f"    Demucs outputs: {demucs_count}")
        log("")

    finally:
        # Cleanup temp directory
        if not args.keep_temp:
            shutil.rmtree(temp_dir, ignore_errors=True)
        else:
            log(f"Temp files kept at: {temp_dir}")

    log("Done!")
    return 0


if __name__ == '__main__':
    sys.exit(main())
